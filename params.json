{"name":"Router.js","tagline":"Router.js is a simple yet powerful javascript plugin to handle hash fragment in order to route requests","body":"Router.js\r\n=========\r\n\r\n[![Build Status](https://travis-ci.org/ramiel/router.js.svg?branch=master)](https://travis-ci.org/ramiel/router.js)\r\n\r\nDiscover on [Ramiel's creations](http://ramielcreations.com/projects/router-js/ \"Ramiel's creations page\")\r\n\r\nRouter.js is a simple yet powerful javascript plugin to handle hash fragment in order to route request.\r\nRouter.js helps you to intercept request done trough fragment and match them using string or regular expressions.\r\n\r\n##Basics\r\n\r\nInclude Router.js in your application\r\n\r\n####Standard\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"js/router.js\">\r\n```\r\n\r\n####RequireJS\r\n```javascript\r\n//Example\r\nrequire([\"router\", ...], function(Router, ...) {\r\n\tvar router = new Router();\r\n\t//...\r\n});\r\n```\r\n\r\n\r\naccording to your directory template.\r\n\r\nNow just define a simple route. A route is made of two components\r\n\r\n* Matching string/regexp\r\n* Callback\r\n\r\nLet's see\r\n\r\n```javascript\r\nvar router = new Router()\r\n   \t.addRoute('#/users', function(req, next){\r\n\t\t/* Do something */\r\n\t});\r\n```\r\n\r\nThere are three noticeble aspects. Your router object and all its functions are chainable. So after an `addRoute` Route you can chain onther one and so on.\r\nThe matching string is '#/users', so if your fragment match this pattern your callback will be fired.\r\n\r\nCallback is populated with two arguments:\r\n\r\n* `req`\r\n* `next`\r\n\r\n\r\nreq is an object containing\r\n\r\n1. `href`, which is the url that matched\r\n2. `params`, all the params recognized in the url. We will talk about this in a while\r\n3. `query`, all the params passed as regular html query string\r\n\r\nWhat if more than a route match your url? Well, the next parameter will be populated with a function you can call to execute the next route which match. Elsewhere next is null\r\n\r\n**Note**:\r\n```\r\nMethod `addRoute` has many aliases. You can use also: `add`, `route`, `get`!\r\n```\r\n\r\n###Options\r\n\r\nRouter constructor accept an object for options\r\n\r\n```javascript\r\nvar options = {ignorecase: true}\r\nvar router = new Router(options);\r\n```\r\n\r\nValid options:\r\n\r\n1. `ignorecase` : The router do not consider casing. Default: `true`\r\n\r\n\r\n###Parametric route\r\n\r\nLet's see this:\r\n\r\n```javascript\r\nrouter\r\n\t.addRoute('#/users/:username', function(req,next){\r\n\t\tvar username = req.params.username;\r\n\t});\r\n```\r\n\r\nwell, if the called url is 'http://www.webapp.com/#/users/john', then `username` in the callback will be 'john'!\r\n\r\nYou can use as many params you want, they will appear in the `params` property of `req` object.\r\n\r\n\r\n###Query string\r\n\r\nUsing previous example if we call 'http://www.webapp.com/#/users/jhon?key=value&foo=bar' then in req `query` will be populated and will be the following object\r\n\r\n```javascript\r\n...\r\nquery: {\r\n\tkey: 'value',\r\n\tfoo: 'bar'\t\r\n}\r\n```\r\nso you can write\r\n```javascript\r\nrouter\r\n\t.addRoute('#/users/:username', function(req,next){\r\n\t\tvar foo = (req.query && req.query.foo) ? req.query.foo : 'not foo';\r\n\t});\r\n```\r\n\r\n###Req.get - One method to get them all\r\nInstead of looking in req.params and in req.query, you can use `req.get( key, default_value )` method.\r\nIt will look in params, the in query. If nothing has found you can provide a fallback value or `undefined` will be returned.\r\n\r\n```javascript\r\n//Calling #/users/john?age=25\r\nrouter\r\n\t.addRoute('#/users/:username', function(req,next){\r\n\t\tvar username = req.get('username'); //will be 'john' because is found in params\r\n\t\tvar age = req.get('age',18); //will be 25 because is found in query\r\n\t\tvar surname = req.get('surname','Snow'); //will be 'Snow' because of provided default value\r\n\t\tvar address = req.get('address'); //will be undefined\r\n\t});\r\n```\r\n\r\n###Special symbols\r\n\r\nThe other symbol you can use in your route is `*`. It matches every word before next backslash.\r\nConsider:\r\n\r\n```javascript\r\nrouter\r\n\t.addRoute('#/users/*', function(req,next){\r\n\t\t/* First word after /users/ will match this route */\r\n\t});\r\n```\r\n\r\nNow all of this url will match the rule:\r\n\r\n* http://www.webapp.com/#/users/john\r\n* http://www.webapp.com/#/users/asdasd\r\n* http://www.webapp.com/#/users/lua\r\n\r\nThe url http://www.webapp.com/#/users/john/foo will not match! Remember that I've said 'before next backslash'!\r\nTo match even it you must use the `**` matcher. It means **everything**\r\n\r\n```javascript\r\nrouter\r\n\t.addRoute('#/users/**', function(req,next){\r\n\t\t/* Everithing after /users/ will match this route */\r\n\t});\r\n```\r\n\r\nAll of this urls match the rule:\r\n\r\n* http://www.webapp.com/#/users/john\r\n* http://www.webapp.com/#/users/john/snow\r\n* http://www.webapp.com/#/users/john/snow/wolf\r\n\r\n##Next argument\r\n\r\nConsidering this routes:\r\n\r\n```javascript\r\nrouter\r\n\t.addRoute('#/users/:username', function(req,next){\r\n\t\t\tvar username = req.params.username;\r\n\t\t\tif( username != 'admin' && next instanceof Function)\r\n\t\t\t\tnext();\r\n\t\t\t\t\r\n\t})\r\n\t.addRoute('#/users/*', function(req,next){\t\t\t\t\t\r\n\t\talert('You are not admin!');\r\n\t});\r\n```\r\n\r\nAs you can see both the routes match the url `http://www.webapp.com/#/users/john`. In Router.js only the first declared match will be called unless you explicitly\r\ncall next, then also the second match will be fired and so on. Remember, `next` will be a function only if another route matches.\r\n\r\nNext will be useful also to fire erros, we will see this in a while, after talking about error handling\r\n\r\n**Note**:\r\n```\r\nHave you noticed that addRoute are chainable? This is true for every router methods!\r\n```\r\n\r\n##Error handling\r\n\r\nWe can handle errors just like http protocol handle it, by http codes.\r\nAn example is better than million words\r\n\r\n```javascript\r\nrouter\r\n\t.addRoute('#/users/:username', function(req,next){\r\n\t\t/*do something*/\r\n\t})\r\n\t.errors(404, function( err, href){\r\n\t\talert('Page not foud!' + href );\r\n\t});\r\n```\r\n\r\nIn this example if we point browser to `http://www.webapp.com/#/route/inexistent` no route will match our url. Router.js will fire a '404' error.\r\nYou can subscribe to 404 situations just with `.errors(404, function(err,href){...})`\r\n\r\nRouter will match for you 404 and 500 situation but will fire a general error for all http code you forgot to register\r\n\r\n##Befores\r\n\r\nSometimes you just want to execute some actions before the route matches and then continue on regular matches. Then `before` is what you need.\r\n\r\n```javascript\r\nrouter\r\n\t.before(function(req,next){\r\n\t\tif( userIsLogged() === true)\r\n\t\t\tnext();\r\n\t\telse\r\n\t\t\tnext( new Error('User not logged'), 403);\r\n\t})\r\n\r\n\t.addRoute('#/users/:username', function(req,next){\r\n\t\t\t\t\t\t/*do something*/\r\n\t})\r\n\t\r\n\t.error(403, function(err, href){\r\n\t\tconsole.error('While attempting to access to '+ href +' the following error happened: '+err.message);\r\n\t});\r\n```\r\n\r\n`Befores` will be executed before normal route. If `next` is called in before then the route is followed, else if `next` is called with an error then the error is fired and the route is not followed.\r\nYou can specify even error type (403 in this case), elsewhere it will be a 500\r\n\r\nYou can add as many `befores` you want, they will be fired sequentially when you call `next`\r\n\r\n```javascript\r\nrouter.before(function(){...})\r\n\t  .before(function(){...});\r\n```\r\n\r\nRemember that in before req has just `href` property cause is the only you know at before time. \r\n\t\t  \r\n##This meaning\r\n\r\nContext inside callback, befores or errors have no special meaning to avoid complexity. If you need to force your context inside a callback you can use `bind`.\r\nBind is the browser implementation or our if missing. Let's see at an example\r\n\r\n```javascript\r\nfunction(){\r\n\r\n\tthis.property = 'foo';\r\n\t\r\n\tvar router = new Router()\r\n\t\t\t\t\t.route('#/mine/route', function(req,next){\r\n\t\t\t\t\t\t\tvar p = this.property;\r\n\t\t\t\t\t\t\tconsole.log(p); /* will print 'foo' */\r\n\t\t\t\t\t\t\trouter.redirect('#/'+p);\r\n\t\t\t\t\t}.bind(this));\r\n\r\n}\r\n```\r\n\r\nIf you need your router inside a callback just refer to it as router.\r\nHave you noticed redirect method? Well it's time to talk about utility methods\r\n\r\n##Utility methods\r\n\r\nIn Router.js are present some utility methods.\r\n\r\n- `redirect`\r\n```javascript\r\nrouter.redirect(url)\r\n```\r\n\r\nthis will redirect your application to desired url firing routes normally\r\n\r\n- `setLocation`\r\n```javascript\r\nrouter.setLocation(url)\r\n```\r\n\r\nthis will redirect your application to desired url **WITHOUT** firing any routes!\r\n\r\n- `play` `pause`\r\n```javascript\r\nrouter.pause();\r\ndocument.location.href='/#/ignore/me'; //This will be ignored until you call play\r\nrouter.play();\r\n```\r\n\r\n`Pause` stop router to react to hash changes. `Play` ripristinate router functionalities.\r\n\r\n##RegExp\r\n\r\nWe already said that you can use regular expression to better match your route\r\n\r\n```javascript\r\nrouter.addRoute(/#\\/foo\\/bar\\/?(.*)/i, function(req, next){\r\n\t\r\n\t/* req gained splats property which contains an array with all your custom matches*/\r\n});\r\n```\r\n\r\nSo calling 'http://www.webapp.com/#/foo/bar/custom' will follow the route and in req you will find a property called splats.\r\nSplats is an array containing all regexp matches (everyting between two '( )' ). In this cas `req.splats[0]` is `custom`\r\n\r\nYou can use regular expression to obtain more grain fined routes but it's up to you to handle them correctly\r\n\r\n\r\n##Run and Destroy\r\n\r\nRouter has a special method. You can call run after you have setted all your route to immediately launch routes parsing.\r\nRun has a parameter, 'startUrl'. If is setted it will redirect immediately to that url, alse it will read current browser url.\r\nIf you do not call run Router will do nothing until next fragment change.\r\n\r\n```javascript\r\nrouter\r\n\t.addRoute('#/users/:username', function(req, next){\r\n\t  /* code */\r\n\t})\r\n\t.run('#/');\r\n```\r\nIf you need to dispose a router, you have to call `destroy` to remove any event handler and then simply set router to `null`\r\n\r\n```javascript\r\nrouter.destroy();\r\nrouter = null;\r\n//all clean\r\n```\r\n\r\n#Why\r\n\r\n* I've used different router like library but some do too few, other too much. I need a little, clear script which do the essential.\r\n\r\n* Code written using Router.js is higly readable\r\n\r\n##Compatibility\r\nDesktop:\r\n\r\n- Chrome 5.0+\r\n- Firefox 3.6+\r\n- Safari 5.0+\r\n- Opera 10.6+\r\n- IE 8+\r\n\r\nMobile:\r\n- iOS Safari 4.0+\r\n- Android \r\n\t- Browser 2.2+\r\n    - Chrome all\r\n    - Firefox all\r\n- IE all\r\n- Opera Mobile 11.0+\r\n \r\n\t\r\n## Author\r\n\r\n[Fabrizio 'ramiel' Ruggeri](http://ramielcreations.com/ \"Ramiel's creations page\")","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}